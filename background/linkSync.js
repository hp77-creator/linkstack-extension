import { WebAuthFlow } from './auth.js';

export class LinkSync {
  constructor() {
    this.auth = new WebAuthFlow();
    this.initialized = false;
  }

  async initialize() {
    if (!this.initialized) {
      await this.auth.initialize();
      this.initialized = true;
    }
    return this.auth.getAccessToken();
  }

  getStashFilename() {
    const now = new Date();
    return `linkstash-${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}.md`;
  }

  extractUrlsFromMarkdown(markdown) {
    const urlRegex = /- URL: (.*?)[\r\n]/g;
    const urls = [];
    let match;
    
    while ((match = urlRegex.exec(markdown)) !== null) {
      urls.push(match[1].trim());
    }
    
    return urls;
  }

  formatLinkAsMarkdown(link) {
    const created = new Date(link.createdAt);
    const completed = link.completedAt ? new Date(link.completedAt) : null;
    
    const formatDate = (date) => {
      const month = date.toLocaleString('en-US', { month: 'short' });
      const day = date.getDate();
      const year = date.getFullYear();
      const hour = String(date.getHours()).padStart(2, '0');
      const minute = String(date.getMinutes()).padStart(2, '0');
      const second = String(date.getSeconds()).padStart(2, '0');
      return `${month} ${day}, ${year} ${hour}:${minute}:${second}`;
    };

    let markdown = `### ${link.title}
- URL: ${link.url}
- Type: ${link.type}
- Added: ${formatDate(created)}
- Status: ${link.isCompleted ? 'READ' : 'UNREAD'}`;

    if (completed) {
      markdown += `\n- Completed: ${formatDate(completed)}`;
    }

    markdown += `\n- Tags: ${link.tags.map(tag => `#${tag}`).join(' ')}`;

    if (link.notes) {
      markdown += `\n- Notes:\n  \`\`\`\n  ${link.notes}\n  \`\`\``;
    }

    markdown += '\n\n';
    return markdown;
  }

  async listMarkdownFiles() {
    const token = this.auth.getAccessToken();
    if (!token) {
      throw new Error('Not authenticated');
    }

    const repoName = await this.getRepoName();
    const response = await fetch(`https://api.github.com/repos/${await this.getUsername()}/${repoName}/contents/`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    });

    if (!response.ok) {
      throw new Error('Failed to list repo contents');
    }

    const contents = await response.json();
    return contents
      .filter(item => item.type === 'file' && item.name.startsWith('linkstash-') && item.name.endsWith('.md'))
      .map(file => file.name);
  }

  async getAllExistingUrls() {
    const files = await this.listMarkdownFiles();
    const urls = new Set();

    for (const filename of files) {
      const content = await this.getRepoContent(filename);
      if (content) {
        const decoder = new TextDecoder();
        const bytes = Uint8Array.from(atob(content.content), c => c.charCodeAt(0));
        const fileContent = decoder.decode(bytes);
        const fileUrls = this.extractUrlsFromMarkdown(fileContent);
        fileUrls.forEach(url => urls.add(url));
      }
    }

    return urls;
  }

  async createLink(link) {
    const token = this.auth.getAccessToken();
    if (!token) {
      throw new Error('Not authenticated');
    }

    // Validate tags
    if (!link.tags || link.tags.length === 0) {
      throw new Error('At least one tag is required');
    }

    // Format link data to match Android app structure
    const linkData = {
      id: crypto.randomUUID(),
      url: link.url,
      title: link.title || '',
      description: link.description || '',
      previewImageUrl: link.previewImageUrl || null,
      type: link.type || 'OTHER',
      createdAt: Date.now(),
      reminderTime: null,
      isArchived: false,
      isFavorite: false,
      isCompleted: false,
      completedAt: null,
      notes: null,
      lastSyncedAt: null,
      syncError: null,
      scrollPosition: 0,
      tags: link.tags || []
    };

    try {
      // Check if URL exists in any file
      const existingUrls = await this.getAllExistingUrls();
      if (existingUrls.has(linkData.url)) {
        console.log('Link already exists in another file, skipping...');
        return linkData;
      }

      const filename = this.getStashFilename();
      // Get repo content first
      const content = await this.getRepoContent(filename);
      
      // Format the new link as markdown
      const markdownContent = this.formatLinkAsMarkdown(linkData);
      
      if (content) {
        // If file exists, decode existing content
        const decoder = new TextDecoder();
        const bytes = Uint8Array.from(atob(content.content), c => c.charCodeAt(0));
        const existingContent = decoder.decode(bytes);
        
        // Find the footer position
        const footerIndex = existingContent.lastIndexOf('\n---\nGenerated by LinkStash');
        if (footerIndex !== -1) {
          // Insert new content before the footer
          const newContent = existingContent.slice(0, footerIndex) + 
                           markdownContent +
                           existingContent.slice(footerIndex);
          await this.updateRepoFile(filename, newContent, content.sha);
        } else {
          // No footer found, just append
          await this.updateRepoFile(
            filename, 
            existingContent + markdownContent, 
            content.sha
          );
        }
      } else {
        // Create new file with link and footer
        const fileContent = markdownContent + '\n---\nGenerated by LinkStash';
        await this.updateRepoFile(filename, fileContent);
      }

      return linkData;
    } catch (error) {
      console.error('Failed to sync link:', error);
      throw error;
    }
  }

  async getRepoContent(path) {
    const token = this.auth.getAccessToken();
    if (!token) {
      throw new Error('Not authenticated');
    }

    const repoName = await this.getRepoName();
    const response = await fetch(`https://api.github.com/repos/${await this.getUsername()}/${repoName}/contents/${path}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    });

    if (response.status === 404) {
      return null;
    }

    if (!response.ok) {
      throw new Error('Failed to get repo content');
    }

    return await response.json();
  }

  async updateRepoFile(path, content, sha = null) {
    const token = this.auth.getAccessToken();
    if (!token) {
      throw new Error('Not authenticated');
    }

    const body = {
      message: `Update ${path}`,
      content: btoa(content)
    };

    if (sha) {
      body.sha = sha;
    }

    const repoName = await this.getRepoName();
    const response = await fetch(`https://api.github.com/repos/${await this.getUsername()}/${repoName}/contents/${path}`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(body)
    });

    if (!response.ok) {
      throw new Error('Failed to update file');
    }

    return await response.json();
  }

  async getUsername() {
    const token = this.auth.getAccessToken();
    if (!token) {
      throw new Error('Not authenticated');
    }

    const response = await fetch('https://api.github.com/user', {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    });

    if (!response.ok) {
      throw new Error('Failed to get user info');
    }

    const data = await response.json();
    return data.login;
  }

  async ensureRepoExists() {
    const token = this.auth.getAccessToken();
    if (!token) {
      throw new Error('Not authenticated');
    }

    try {
      const username = await this.getUsername();
      // Check if repo exists
      const repoName = await this.getRepoName();
      const response = await fetch(`https://api.github.com/repos/${username}/${repoName}`, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });

      if (response.status === 404) {
        // Create repo if it doesn't exist
        await fetch('https://api.github.com/user/repos', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: repoName,
            description: 'LinkStack synchronized links',
            private: true
          })
        });
      } else if (!response.ok) {
        throw new Error('Failed to check repo');
      }
    } catch (error) {
      console.error('Failed to ensure repo exists:', error);
      throw error;
    }
  }

  async getRepoName() {
    const { repoName } = await chrome.storage.local.get('repoName');
    return repoName || 'linkstash-sync'; // Default to 'linkstash-sync' if not set
  }
}
